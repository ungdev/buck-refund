import { Body, Controller, Get, Headers, HttpCode, HttpStatus, Post } from '@nestjs/common';
import { AuthService } from './auth.service';
import AuthSignInReqDto from './dto/req/auth-sign-in-req.dto';
import { IsPublic } from './decorator';
import { AppException, ERROR_CODE } from '../exceptions';
import { ApiBody, ApiCreatedResponse, ApiHeader, ApiOkResponse, ApiOperation, ApiTags } from '@nestjs/swagger';
import AccessTokenResponse from './dto/res/access-token-res.dto';
import TokenValidityResDto from './dto/res/token-validity-res.dto';
import { ApiAppErrorResponse } from '../app.dto';

@Controller('auth')
@ApiTags('Authentication')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @IsPublic()
  @Post('login')
  @ApiOperation({
    description: 'Signs in the user, and returns an authentication token. This token should be used as a Bearer token.',
  })
  @ApiBody({ type: AuthSignInReqDto })
  @ApiOkResponse({
    description: 'The user was successfully authenticated, the token is returned.',
  })
  @ApiAppErrorResponse(ERROR_CODE.INVALID_CREDENTIALS, 'Either the login or the password is incorrect')
  async signin(@Body() dto: AuthSignInReqDto): Promise<AccessTokenResponse> {
    const { token, id } = await this.authService.signin(dto);
    if (!token) throw new AppException(ERROR_CODE.INVALID_CREDENTIALS);
    const user = await this.authService.getUser(id);
    return {
      access_token: token,
      currentBalance: user.balance,
      firstName: user.firstName,
      paymentMethodRegistered: !!user.iban,
    };
  }

  @HttpCode(HttpStatus.OK)
  @IsPublic()
  @Get('login')
  @ApiOperation({
    description: 'Checks if the user is signed in. It returns a boolean indicating if the user is signed in.',
  })
  @ApiHeader({
    name: 'Authorization',
    description: 'The token should be passed as a Bearer token, as if the user was signed in.',
    required: true,
  })
  @ApiCreatedResponse({
    description: 'The user is signed in.',
    type: TokenValidityResDto,
  })
  @ApiAppErrorResponse(ERROR_CODE.NO_TOKEN, 'The token was not passed in the `Authorization` header')
  @ApiAppErrorResponse(
    ERROR_CODE.INVALID_TOKEN_FORMAT,
    'The token is not in the right format. This may happen if you did not use the syntax `Bearer {token there}`, or the token was not generated by the API',
  )
  async isSignedIn(@Headers() headers: Record<string, string>): Promise<TokenValidityResDto> {
    const authorizationHeader = headers['authorization'];
    if (!authorizationHeader) {
      throw new AppException(ERROR_CODE.NO_TOKEN);
    }
    const match = new RegExp(/^Bearer\s+(.*)$/).exec(authorizationHeader);
    if (!match) {
      throw new AppException(ERROR_CODE.INVALID_TOKEN_FORMAT);
    }
    const { valid, id } = this.authService.isTokenValid(match[1]);
    const user = id ? await this.authService.getUser(id) : undefined;
    return {
      valid,
      currentBalance: user?.balance,
      firstName: user?.firstName,
      paymentMethodRegistered: !!user?.iban,
    };
  }
}
